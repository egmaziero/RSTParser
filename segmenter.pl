use strict;my $session = $ARGV[0];open(SEGMENTS,">:utf8","temp/segments_".$session.".seg") or die "Error: can't create segments file for $session\n";open(SEGMENTSPAT,">:utf8","temp/segments_Pattern_".$session.".seg") or die "Error: can't create segments file for $session\n";#values of terminalsmy @tid;my @word; my @lemma;my @pos;my @morph;my @sem;my @extra;my $t = 0;#values of non terminalsmy @ntid;my @cat;my @edgeLabel; my @edgeIdRef; my @quantEdges = 0;my $nt = 0;my $ntID;my $seqEdge;my @break;my @infoSegment;open(CONTRACTS,"<resources/contracts.txt") or die "$!\n";my @contracts = <CONTRACTS>;close(CONTRACTS);open(ATTRIBUTION,"<resources/attribVerbs.txt") or die "$!\n";my @attribution = <ATTRIBUTION>;close(ATTRIBUTION);sub getInfos{	#clean the structure	@infoSegment = ();	@break = sort { $a <=> $b } @break;	my $prev = $break[0];	for(my $i=1; $i<=$#break; $i++)	{		my $curr = $break[$i] ;		if ($prev == $curr)		{			splice(@break,$i,1);		}		$prev = $curr;	}	my $index = 0;	foreach(@break)	{		my $b = $_;		$infoSegment[$index] = 		{			break => $b,			restriction => 'nul',			type => 'nul',		};		$index++;	}		$infoSegment[$index] = 	{		break => $t,		restriction => 'nul',		type => 'nul',	};}sub applyRestrictions{	my $currIndex = 0;	my @infos = ();	for(my $i=0; $i<=$#infoSegment; $i++)	{		#verification per segment		my $containVerb = 0;		my $parentheticalComplete = -1; # 3 states (-1 0  and 1)		my $isElaboration = 0;		for(my $j=$currIndex; $j<$infoSegment[$i]->{break}; $j++)		{			if ($pos[$j] =~ /^v/)			{				$containVerb = 1;			}			elsif (isOpenPar($word[$j]))			{				$parentheticalComplete = 0;				for(my $k=($j+1); $k<=$infoSegment[$i]->{break}; $k++)				{					if (isClosePar($word[$k]))					{						$parentheticalComplete = 1;					}				}			}			elsif (($pos[$j] eq "v-ger") and ($pos[$j-1] eq "pu"))			{				$isElaboration = 1;			}			elsif (($pos[$j] eq "v-pcp") and ($pos[$i-1] eq "pu"))			{				$isElaboration = 1;			}			elsif(($pos[$i] eq "conj-s") and ($pos[$i-1] eq "pu"))			{				$isElaboration = 1;			}		}		#validations		if ($containVerb == 0)		{			if ($parentheticalComplete == 1)			{				$infoSegment[$i]->{type} = "isParenth";			}			else			{				$infoSegment[$i]->{restriction} = "noVerb";			}					}		if($parentheticalComplete == 1)		{			$infoSegment[$i]->{type} = "isParenth";		}		if ($parentheticalComplete == 0)		{			$infoSegment[$i]->{restriction} = "noCloseParenth";		}		if ($isElaboration == 1)		{			$infoSegment[$i]->{type} = "isElab";		}		$currIndex = $infoSegment[$i]->{break};	}	for(my $i=0; $i<=$#infoSegment;$i++)	{		#last segment		if ($i == $#infoSegment)		{			if ($infoSegment[$i]->{restriction} eq "noVerb")			{				if (($infoSegment[$i-1]->{type} ne "isElab") and ($infoSegment[$i-1]->{type} ne "isParenth"))				{					$infoSegment[$i-1]->{break} = $infoSegment[$i]->{break};				}			}			if ($infoSegment[$i]->{restriction} eq "noCloseParenth")			{				$infoSegment[$i-1]->{break} = $infoSegment[$i]->{break};			}		}		else		{			if ($infoSegment[$i]->{restriction} eq "noVerb")			{				if (($infoSegment[$i+1]->{type} ne "isElab") and ($infoSegment[$i+1]->{type} ne "isParenth"))				{					$infoSegment[$i]->{break} = $infoSegment[$i+1]->{break};					}				if ($infoSegment[$i+1]->{restriction} eq "noVerb")				{					$infoSegment[$i]->{break} = $infoSegment[$i+2]->{break};												}			}			if ($infoSegment[$i]->{restriction} eq "noCloseParenth")			{				$infoSegment[$i]->{break} = $infoSegment[$i+1]->{break};			}		}	}	}sub loadStructure{	#values of terminals	 @tid = ();	 @word = (); 	 @lemma = ();	 @pos = ();	 @morph = ();	 @sem = ();	 @extra = ();	 $t = 0;	#values of non terminals	 @ntid = ();	 @cat = ();	 @edgeLabel = (); 	 @edgeIdRef = (); 	 @quantEdges = ();	 $nt = 0;	 $ntID;	 $seqEdge;	 @break = ();	my @vector; #parts of lines	my $file = shift;	open (FILE, $file) or die "Error: can't open $file at segmenter\n";	foreach (<FILE>)	{		 if ($_ =~ /<t id=/)		 {			@vector = split(/"/, $_);			$tid[$t] = $vector[1];			$word[$t] = $vector[3];			$lemma[$t] = $vector[5];			$pos[$t] = $vector[7];			$morph[$t] = $vector[9];			$sem[$t] = $vector[11];			$extra[$t] = $vector[13];			$t++;		 }		 if ($_ =~ /<nt id=/)		 {			@vector = split(/"/,$_);			$ntid[$nt] = $vector[1];			$cat[$nt] = $vector[3];			$quantEdges[$nt] = 0;			$ntID = $ntid[$nt];			$seqEdge = 0;		 }		 if ($_ =~ /<edge label=/)		 {			@vector = split(/"/,$_);			$edgeLabel[$ntID][$seqEdge] = $vector[1];			$edgeIdRef[$ntID][$seqEdge] = $vector[3];			$seqEdge++;			$quantEdges[$nt]++;		 }		 if ($_ =~ /<\/nt>/)		 {			$nt++;		 }	}}sub rules{	#search for breaks based on the lexical and POS	for(my $i=0;$i<=$t;$i++)	{		#Subordinacoes :: para que		if (($pos[$i] eq "conj-s") and ($pos[$i-1] eq "prp"))		{			push(@break,($i-1));		}		# pu conj-s		if (($pos[$i] eq "conj-s") and ($pos[$i-1] eq "pu"))		{			push(@break,($i));		}		#Coordenacoes :: apenas se antes e depois tiver algum verbo		if (($pos[$i] eq "conj-c"))		{			if (BeforeAfter($i) == 2)			{				push(@break,$i);			}		}		#verbos no gerundio ou participio pós pontuação		elsif (($pos[$i] eq "v-ger") and ($pos[$i-1] eq "pu"))		{			push(@break,$i);		}		elsif (($pos[$i] eq "v-pcp") and ($pos[$i-1] eq "pu"))		{			push(@break,$i);		}				#adverbio pós pontuação		elsif (($pos[$i] eq "adv") and ($pos[$i-1] eq "pu"))		{			if (BeforeAfter($i) == 2)			{				push(@break,$i);			}		}		#clausulas relativas		elsif (($extra[$i] eq "clb rel") and ($word[$i-1] eq ","))		{			push(@break,$i);			#search for the end of the relative clause			for(my $j=($i+1); $j<=$t; $j++)			{				if ($word[$j] eq ",")				{					push(@break,($j+1));				}			}		}		#parenthetical e same unit		if ($word[$i] eq "(")		{			push(@break,$i);			#search for the end of the parenthetical			for(my $j=($i+1); $j<=$t; $j++)			{				if ($word[$j] eq ")")				{					if ($pos[$j+1] eq "pu")					{						push(@break,($j+2));					}					else					{						push(@break,($j+1));					}				}			}		}		#attribution		foreach(@attribution)		{			my $attributionVerb = trim($_);			#something said			if ((lc($lemma[$i]) eq lc($attributionVerb)) and (($pos[$i-1] eq "n") or ($pos[$i-1] eq "prop")))			{				push(@break,($i+1));			}			#, said someone			if ((lc($lemma[$i]) eq lc($attributionVerb)) and ($pos[$i-1] eq "pu"))			{				push(@break,($i));			}		}		#, according to		if (((lc($word[$i]) eq lc("segundo")) or (lc($word[$i]) eq lc("conforme"))) and ($pos[$i-1] eq "pu"))		{			push(@break,($i));		}		#, "para" verbo no infinitivo		if ((lc($word[$i]) eq lc("para")) and ($pos[$i+1] eq "v-inf"))		{			push(@break,($i));		}		#According to ... ,		if (((lc($word[$i]) eq lc("segundo")) or (lc($word[$i]) eq lc("conforme"))) and ($i <= 1))		{			for(my $j=($i+1); $j<=$t; $j++)			{				if ($pos[$j] eq "pu")				{					push(@break,($j+1));				}			}		}	}	for(my $i=0;$i<=$t;$i++)	{		#virgula separando orações		if ($word[$i] eq ",")		{			if (BeforeAfterComma($i) == 2)			{				push(@break,($i+1));			}		}	}}sub BeforeAfter{	my $i = shift;	my $verbBefore = 0;	my $verbAfter = 0;	for(my $j=($i+1); $j<=$t; $j++)	{		if ($pos[$j] =~ /^v/)		{			$verbAfter = 1;		}	}	for(my $j=($i-1); $j>=0; $j--)	{		if ($pos[$j] =~ /^v/)		{			$verbBefore = 1;		}	}	return $verbBefore + $verbAfter;}sub BeforeAfterComma{	my $i = shift;		my $start = 0;	my $end = $t;		foreach(@break)	{		if ($_ < $i)		{			$start = $_;		}		if ($_ > $i)		{			$end = $_;		}	}				my $verbBefore = 0;	my $verbAfter = 0;	for(my $j=($i+1); $j<=$end; $j++)	{		if ($pos[$j] =~ /^v/)		{			$verbAfter = 1;		}	}	for(my $j=($i-1); $j>=$start; $j--)	{		if ($pos[$j] =~ /^v/)		{			$verbBefore = 1;		}	}	return $verbBefore + $verbAfter;}sub contractPrpArt{	my $string = shift;	foreach(@contracts)	{		my @part = split(/=/,$_);		$part[1] = trim($part[1]);		$string =~ s/$part[0] / $part[1] /g;	}	return $string;}sub isOpenPar{	my $string = trim(shift);		if (($string eq "(") or ($string eq "[") or ($string eq "{"))	{		return 1;	}	else	{		return 0;	}}sub isClosePar{	my $string = trim(shift);		if (($string eq ")") or ($string eq "]") or ($string eq "}"))	{		return 1;	}	else	{		return 0;	}}sub printSegments{	my $segment = "";	for(my $i=0; $i<=$#infoSegment; $i++)	{		$word[$infoSegment[$i]->{break}] = "\n".$word[$infoSegment[$i]->{break}];	}	for(my $i=0;$i<=$t;$i++)	{		$word[$i] =~ s/_/ /gi;		$word[$i] =~ s/\n\n\n\n/\n/gi;		$word[$i] =~ s/\n\n\n/\n/gi;		$word[$i] =~ s/\n\n/\n/gi;		$segment .=  $word[$i]." ";	}	#$segment = contractPrpArt($segment);	print SEGMENTS trim($segment)."\n";}sub printSegmentsPattern{	my $segment = "";	for(my $i=0; $i<$#infoSegment; $i++)	{		$word[$infoSegment[$i]->{break}] = "\n".$word[$infoSegment[$i]->{break}];	}	for(my $i=0;$i<$t;$i++)	{		$word[$i] =~ s/\n\n\n\n/\n/gi;		$word[$i] =~ s/\n\n\n/\n/gi;		$word[$i] =~ s/\n\n/\n/gi;		if ($word[$i] =~ /\_/)		{			my @partesWord = split(/_/,$word[$i]);			my @partesLemma = split(/_/,$lemma[$i]);			$word[$i] = "";			for(my $j=0; $j<=$#partesWord; $j++)			{				$word[$i] .= $partesWord[$j]."(".$partesLemma[$j].")_".$pos[$i]." ";			}		}		else		{			$word[$i] .= "(".$lemma[$i].")_".$pos[$i];		}		$segment .=  $word[$i]." ";	}	#$segment = contractPrpArt($segment);	print SEGMENTSPAT trim($segment)."\n";}sub trim($){ my $string = shift; $string =~ s/^\s+//; $string =~ s/\s+$//; return $string;}#MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--MAIN--open(META,"<temp/metaInfos_".$session.".met") or die "Error: can't open meta file for $session\n";my @meta = <META>;close(META);print "Segmenting..."my $paragraph;my $sentence;foreach(@meta){ 	if ($_ =~/\-\-Paragraph/)	{		$paragraph = trim($_);		print SEGMENTS $paragraph."\n";		print SEGMENTSPAT $paragraph."\n";	}	if ($_ =~/^temp\/sentence_/)	{		$sentence = trim($_);		loadStructure($sentence);		$sentence =~ s/temp\///;		print SEGMENTS $sentence."\n";		print SEGMENTSPAT $sentence."\n";		rules();		getInfos();		applyRestrictions();		printSegments();		printSegmentsPattern();	}	if ($_ =~/\-\-End of Paragraph/)	{		print SEGMENTS "End of Paragraph\n";		print SEGMENTSPAT "End of Paragraph\n";	}	if ($_ =~/\-\-End of Sentence/)	{		print SEGMENTS "End of Sentence\n";		print SEGMENTSPAT "End of Sentence\n";	}}close(SEGMENTS);close(SEGMENTSPAT);